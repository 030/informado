package main

import (
	"encoding/xml"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"regexp"

	"net/http"

	"github.com/gocarina/gocsv"
)

func hello() string {
	return "world"
}

func readURL(u string) ([]byte, error) {
	var bodyBytes []byte

	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
	req, err := http.NewRequest("GET", u, nil)
	if err != nil {
		return nil, err
	}

	// Required to parse Reddit feeds
	req.Header.Set("user-agent", "hello:world:v0.0 (by /u/ocelost)")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	//https://stackoverflow.com/a/38673698/2777965
	if resp.StatusCode == http.StatusOK {
		bodyBytes, err = ioutil.ReadAll(resp.Body)
		if err != nil {
			return nil, err
		}
	} else {
		return nil, fmt.Errorf("StatusCode not 200, but '%v'", resp.StatusCode)
	}
	return bodyBytes, nil
}

type feed struct {
	Feed  xml.Name `xml:"feed"`
	Entry []Entry  `xml:"entry"`
}
type Entry struct {
	XMLName xml.Name `xml:"entry"`
	Updated string   `xml:"updated"`
	Title   string   `xml:"title"`
}

type rss struct {
	XMLName xml.Name `xml:"rss"`
	Item    []Item   `xml:"channel>item"`
}
type Item struct {
	XMLName xml.Name `xml:"item"`
	PubDate string   `xml:"pubDate"`
	Title   string   `xml:"title"`
}

func atom(dateStr string, u string) error {
	fmt.Println(u)
	b, err := readURL(u)
	if err != nil {
		return err
	}
	var f feed
	if err = xml.Unmarshal(b, &f); err != nil {
		return err
	}
	for i := 0; i < len(f.Entry); i++ {
		updated := f.Entry[i].Updated
		match, err := regexp.MatchString(dateStr, updated)
		if err != nil {
			return err
		}
		if match {
			fmt.Println(updated + " " + f.Entry[i].Title)
		}
	}
	fmt.Println("============================================================")
	return nil
}

func standard(dateStr string, u string) error {
	fmt.Println(u)
	b, err := readURL(u)
	if err != nil {
		return err
	}
	var r rss
	if err = xml.Unmarshal(b, &r); err != nil {
		return err
	}
	for i := 0; i < len(r.Item); i++ {
		pubDate := r.Item[i].PubDate
		match, err := regexp.MatchString(dateStr, pubDate)
		if err != nil {
			return err
		}
		if match {
			fmt.Println(pubDate + " " + r.Item[i].Title)
		}
	}
	fmt.Println("============================================================")
	return nil
}

type RSSFeeds struct {
	Type string `csv:"type"`
	URL  string `csv:"url"`
}

func csv(f string) ([]*RSSFeeds, error) {
	u, err := os.OpenFile(f, os.O_RDWR|os.O_CREATE, os.ModePerm)
	if err != nil {
		return nil, err
	}
	defer u.Close()

	r := []*RSSFeeds{}

	if err := gocsv.UnmarshalFile(u, &r); err != nil {
		return nil, err
	}
	return r, err
}

func main() {
	d := flag.String("date", "^(2020-05-17T1[1-9]|.*17 May 2020 1[5-9]).*$", "Get the RSS feeds from a certain date")
	f := flag.String("file", "informado.csv", "The file that contains a list of RSS URLs")
	flag.Parse()
	urls, err := csv(*f)
	if err != nil {
		log.Fatal(err)
	}
	for _, u := range urls {
		switch t := u.Type; t {
		case "atom":
			if err := atom(*d, u.URL); err != nil {
				log.Fatal(err)
			}
		case "standard":
			if err := standard(*d, u.URL); err != nil {
				log.Fatal(err)
			}
		default:
			fmt.Printf("Unsupported type '%v'.\n", t)
		}
	}
}
