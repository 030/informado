package main

import (
	"flag"
	"fmt"
	"informado/news"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"strconv"
	"sync"
	"time"

	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/plumbing/object"
	"github.com/go-git/go-git/v5/plumbing/transport/ssh"
	"github.com/gocarina/gocsv"
	"github.com/hashicorp/go-retryablehttp"
)

func readURL(u string) ([]byte, error) {
	var bodyBytes []byte

	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
	req, err := http.NewRequest("GET", u, nil)
	if err != nil {
		return nil, err
	}

	retryClient := retryablehttp.NewClient()
	retryClient.RetryMax = 10
	retryClient.Logger = nil

	standardClient := retryClient.StandardClient() // *http.Client

	// Required to parse Reddit feeds
	req.Header.Set("user-agent", "hello:world:v0.0 (by /u/ocelost)")

	resp, err := standardClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	//https://stackoverflow.com/a/38673698/2777965
	if resp.StatusCode == http.StatusOK {
		bodyBytes, err = ioutil.ReadAll(resp.Body)
		if err != nil {
			return nil, err
		}
	} else {
		return nil, fmt.Errorf("StatusCode not 200, but '%v'", resp.StatusCode)
	}
	return bodyBytes, nil
}

func rss(r news.RSS, url string) error {
	byte, err := readURL(url)
	if err != nil {
		return err
	}
	a, err := r.Parse(byte)
	if err != nil {
		return err
	}
	if err := a.Print(); err != nil {
		return err
	}
	return nil
}

type RSSFeeds struct {
	Type  string `csv:"type"`
	URL   string `csv:"url"`
	Error error
}

func csv(f string) ([]*RSSFeeds, error) {
	u, err := os.OpenFile(f, os.O_RDWR|os.O_CREATE, os.ModePerm)
	if err != nil {
		return nil, err
	}
	defer u.Close()

	r := []*RSSFeeds{}
	if err := gocsv.UnmarshalFile(u, &r); err != nil {
		return nil, err
	}

	return r, err
}

var wg sync.WaitGroup

func newsItems(c chan *RSSFeeds, r *RSSFeeds) {
	defer wg.Done()
	var e error

	switch t := r.Type; t {
	case "atom":
		if err := rss(news.Atom{}, r.URL); err != nil {
			e = err
		}
	case "standard":
		if err := rss(news.Standard{}, r.URL); err != nil {
			e = err
		}
	default:
		e = fmt.Errorf("Unsupported type '%v'", t)
	}

	c <- &RSSFeeds{r.Type, r.URL, e}
}

func read(urls []*RSSFeeds) error {
	c := make(chan *RSSFeeds, len(urls))
	for _, a := range urls {
		wg.Add(1)
		go newsItems(c, a)
	}
	wg.Wait()
	close(c)
	for item := range c {
		if item.Error != nil {
			return fmt.Errorf("Type: '%v'. URL: '%v', Err: '%v'", item.Type, item.URL, item.Error)
		}
	}
	return nil
}

func parse(input string) error {
	urls, err := csv(input)
	if err != nil {
		return err
	}
	if err := read(urls); err != nil {
		return err
	}
	return nil
}

func currentTimeToDisk() error {
	now := time.Now()
	epoch := now.Unix()

	file, err := os.Create("/tmp/some-repo3/.informado")
	if err != nil {
		return err
	}
	defer file.Close()

	_, err = file.WriteString(strconv.FormatInt(epoch, 10))
	if err != nil {
		return err
	}

	return nil
}

func main() {
	input := flag.String("file", "informado.csv", "The file that contains a list of RSS URLs")

	flag.Parse()

	// Clone the given repository to the given directory
	//Info("git clone %s %s --recursive", "git@gist.github.com:295af749c3f61b3e420a2b164ec407c4.git", ".")
	// url := "git@gist.github.com:295af749c3f61b3e420a2b164ec407c4.git"
	url := "git@github.com:030/informado-time.git"

	publicKeys, err := ssh.NewPublicKeysFromFile("git", "/home/ben/.ssh/id_rsa_informado", "oh oh oh 123")
	if err != nil {
		fmt.Println(err)
	}
	r, err := git.PlainClone("/tmp/some-repo3", false, &git.CloneOptions{
		URL:      url,
		Auth:     publicKeys,
		Progress: os.Stdout,
	})

	if err != nil {
		fmt.Println(err)
	}

	// ... retrieving the branch being pointed by HEAD
	ref, err := r.Head()
	//CheckIfError(err)
	if err != nil {
		fmt.Println(err)
	}

	// ... retrieving the commit object
	commit, err := r.CommitObject(ref.Hash())
	//	CheckIfError(err)
	if err != nil {
		fmt.Println(err)
	}

	fmt.Println(commit)

	//
	//
	//
	if err := parse(*input); err != nil {
		log.Fatal(err)
	}
	//
	//
	//

	if err := currentTimeToDisk(); err != nil {
		log.Fatal(err)
	}

	//
	// commit
	//

	r, err = git.PlainOpen("/tmp/some-repo3")
	if err != nil {
		fmt.Println(err)
	}

	w, err := r.Worktree()
	// Adds the new file to the staging area.

	_, err = w.Add(".informado")
	if err != nil {
		fmt.Println(err)
	}

	// We can verify the current status of the worktree using the method Status.

	status, err := w.Status()
	if err != nil {
		fmt.Println(err)
	}

	fmt.Println(status)

	// Commits the current staging area to the repository, with the new file
	// just created. We should provide the object.Signature of Author of the
	// commit Since version 5.0.1, we can omit the Author signature, being read
	// from the git config files.

	commit2, err := w.Commit("example go-git commit", &git.CommitOptions{
		Author: &object.Signature{
			Name:  "John Doe",
			Email: "john@doe.org",
			When:  time.Now(),
		},
	})

	if err != nil {
		fmt.Println(err)
	}

	// Prints the current HEAD to verify that all worked well.

	obj, err := r.CommitObject(commit2)
	if err != nil {
		fmt.Println(err)
	}

	fmt.Println(obj)

	err = r.Push(&git.PushOptions{})
	if err != nil {
		fmt.Println(err)
	}
}
